![image-20230516100551001](https://martin-red-1315612947.cos.ap-shanghai.myqcloud.com/PicGo%E5%9B%BE%E5%BA%8A/image-20230516100551001.png)

### 题目分析

对于$$1000\times 1000$$的矩阵，1%为非零元素，则意味着大约有10000个元素是非零的。

将散列表长度设为20000，那么装填因子大约是50%。是一种常见的方式。

散列函数设计为`H(row,col) = int(row * A + col * (1 - A)) % 20000`，其中`const float A = (sqrt(5) - 1) / 2`。

### 散列函数设计的思路：

为了设计一个合适的散列函数，需要将行号和列号的所有信息尽可能多的映射到散列表的索引上，因此row和col的三位数值都会完整地出现在散列函数的运算中。同时，应尽可能让散列表的冲突尽量减少。通常实际的应用场合中，应当根据具体的存储数据来不断调试合适的散列函数，但既然我们需要设计一个相对通用的散列函数，就可以采取一些经典的设计思路。

这里采用的是一种**乘法散列**的思路：将行号和列号分别乘以一个常数，然后将两个结果相加，最后对散列表的大小取模。这个方式相较于一般的线性探测法计算量稍大，但可能更好地避免聚集性冲突；它也比之前讲过的平方取中法计算量更小，速度更快。

这里常数的选取其实应当根据实际的存储内容进行调整，题目没有给出具体的数据，因此这里选用了一个经典的常数：黄金分割比。为了减少冲突，行号和列号乘的常数应不同，因此我令行号乘以A，列号乘以1-A。

至此，散列函数就可以得到了：`H(row,col) = int(row * A + col * (1 - A)) % 20000`，其中`const float A = (sqrt(5) - 1) / 2`。
